import ts from "typescript";
import fs from "fs";
import crypto from "crypto";
import path from "path";
import { transformNode } from "../transformations/transformNode";
import { PathTranslator } from "./rojoResolver/pathTranslator";
import { RojoResolver } from "./rojoResolver/rojoResolver";
import { Cache } from "../util/cache";
import { getPackageJson } from "../util/functions/getPackageJson";
import { BuildInfo } from "./buildInfo";
import { Logger } from "./logger";
import { assert } from "./rojoResolver/util/assert";
import { SymbolProvider } from "./symbolProvider";
import { f } from "../util/factory";
import { isPathDescendantOf } from "../util/functions/isPathDescendantOf";
import { getDeclarationName } from "../util/functions/getDeclarationName";
import Hashids from "hashids";
import { ClassInfo } from "../types/classes";
import { CallMacro } from "../transformations/macros/macro";
import { CALL_MACROS } from "../transformations/macros/call/callMacros";
import { isCleanBuildDirectory } from "../util/functions/isCleanBuildDirectory";

const IGNORE_RBXTS_REGEX = /node_modules\/@rbxts\/(compiler-types|types)\/.*\.d\.ts$/;

export interface TransformerConfig {
	/**
	 * An internal option that should not be used.
	 * This is used to compile the framework package, turning this on in your game will cause many errors.
	 */
	$rbxpackmode$?: boolean;

	/**
	 * This is the salt used for hashes generated by Flamework.
	 * Defaults to a randomly generated 64 byte salt.
	 */
	salt?: string;

	/**
	 * This can be used to lower collision chance with packages.
	 * Defaults to package name.
	 */
	hashPrefix?: string;

	/**
	 * Whether to automatically generate the identifiers for exports.
	 * This is recommended for packages but it is not recommended to
	 * enable this in games.
	 */
	preloadIds?: boolean;

	/**
	 * Whether to enable flamework's obfuscation.
	 *
	 * This comprises of:
	 * 1. random event names
	 * 2. shortened ids
	 */
	obfuscation?: boolean;
}

export class TransformState {
	public currentDirectory = this.program.getCurrentDirectory();
	public options = this.program.getCompilerOptions();
	public srcDir = this.options.rootDir ?? this.currentDirectory;
	public outDir = this.options.outDir ?? this.currentDirectory;
	public typeChecker = this.program.getTypeChecker();

	public symbolProvider = new SymbolProvider(this);
	public classes = new Map<ts.Symbol, ClassInfo>();

	public rojoResolver?: RojoResolver;
	public pathTranslator!: PathTranslator;
	public buildInfo!: BuildInfo;

	public packageName: string;
	public isGame: boolean;

	public callMacros = new Map<ts.Symbol, CallMacro>();

	private setupBuildInfo() {
		let baseBuildInfo = BuildInfo.fromDirectory(this.currentDirectory);
		if (!baseBuildInfo || (Cache.isInitialCompile && isCleanBuildDirectory(this.options))) {
			if (this.options.incremental && this.options.tsBuildInfoFile) {
				if (ts.sys.fileExists(this.options.tsBuildInfoFile)) {
					throw new Error(`Flamework cannot be built in a dirty environment, please delete your tsbuildinfo`);
				}
			}
			baseBuildInfo = new BuildInfo(path.join(this.currentDirectory, "flamework.build"));
		}
		this.buildInfo = baseBuildInfo;

		const candidates = Cache.buildInfoCandidates ?? [];
		if (!Cache.buildInfoCandidates) {
			Cache.buildInfoCandidates = candidates;
			const candidatesSet = new Set<string>();
			for (const file of this.program.getSourceFiles()) {
				const buildCandidate = BuildInfo.findCandidateUpper(path.dirname(file.fileName));
				if (
					buildCandidate &&
					buildCandidate !== baseBuildInfo.buildInfoPath &&
					!candidatesSet.has(buildCandidate)
				) {
					candidatesSet.add(buildCandidate);
					candidates.push(buildCandidate);
				}
			}
		}

		for (const candidate of candidates) {
			const relativeCandidate = path.relative(this.currentDirectory, candidate);
			const buildInfo = BuildInfo.fromPath(candidate);
			if (buildInfo) {
				Logger.infoIfVerbose(`Loaded buildInfo at ${relativeCandidate}, next id: ${buildInfo.getLatestId()}`);
				baseBuildInfo.addBuildInfo(buildInfo);
			} else {
				Logger.warn(`Build info not valid at ${relativeCandidate}`);
			}
		}
	}

	private setupRojo() {
		this.pathTranslator = new PathTranslator(this.srcDir, this.outDir, undefined, false);

		const rojoConfig = RojoResolver.findRojoConfigFilePath(this.program.getCurrentDirectory());
		if (rojoConfig) {
			const rojoContents = fs.readFileSync(rojoConfig, { encoding: "ascii" });
			const sum = crypto.createHash("md5").update(rojoContents).digest("hex");

			if (sum === Cache.rojoSum) {
				this.rojoResolver = Cache.rojoResolver;
			} else {
				this.rojoResolver = RojoResolver.fromPath(rojoConfig);
				Cache.rojoSum = sum;
				Cache.rojoResolver = this.rojoResolver;
			}
		}
	}

	constructor(
		public program: ts.Program,
		public context: ts.TransformationContext,
		public config: TransformerConfig,
	) {
		if (config.hashPrefix?.startsWith("$") && !config.$rbxpackmode$) {
			throw new Error(`The hashPrefix $ is used internally by Flamework`);
		}

		this.setupRojo();
		this.setupBuildInfo();
		this.buildInfo.setIdentifierPrefix(config.hashPrefix);

		const { result: packageJson } = getPackageJson(this.currentDirectory);
		assert(packageJson.name);

		this.packageName = packageJson.name;
		this.isGame = !this.packageName.startsWith("@");

		Cache.isInitialCompile = false;
	}

	private areMacrosSetup = false;
	setupMacros() {
		if (this.areMacrosSetup) return;
		this.areMacrosSetup = true;

		for (const macro of CALL_MACROS) {
			const symbols = macro.getSymbol(this);
			if (Array.isArray(symbols)) {
				for (const symbol of symbols) {
					this.callMacros.set(symbol, macro);
				}
				macro._symbols = symbols;
			} else {
				this.callMacros.set(symbols, macro);
				macro._symbols = [symbols];
			}
		}
	}

	public fileImports = new Map<string, ImportInfo[]>();
	addFileImport(file: ts.SourceFile, importPath: string, name: string): ts.Identifier {
		const symbolProvider = this.symbolProvider;

		if (importPath === "@flamework/core") {
			if (
				(file === symbolProvider.flameworkFile.file ||
					this.getSymbol(file) === symbolProvider.flameworkFile.fileSymbol) &&
				name === "Flamework"
			) {
				return f.identifier("Flamework");
			}

			const flameworkDir = path.dirname(symbolProvider.flameworkFile.file.fileName);
			const modulePath = path.join(flameworkDir, name === "Reflect" ? "reflect" : "flamework");

			if (isPathDescendantOf(file.fileName, flameworkDir)) {
				importPath = "./" + path.relative(path.dirname(file.fileName), modulePath) || ".";
			}
		}

		let importInfos = this.fileImports.get(file.fileName);
		if (!importInfos) this.fileImports.set(file.fileName, (importInfos = []));

		let importInfo = importInfos.find((x) => x.path === importPath);
		if (!importInfo) importInfos.push((importInfo = { path: importPath, entries: [] }));

		let identifier = importInfo.entries.find((x) => x.name === name)?.identifier;
		if (!identifier) {
			if (!file.identifiers.has(name)) {
				identifier = f.identifier(name);
				importInfo.entries.push({ name, identifier });
			}
		}

		if (!identifier) {
			start: for (const statement of file.statements) {
				if (!f.is.importDeclaration(statement)) break;
				if (!f.is.string(statement.moduleSpecifier)) continue;
				if (!f.is.importClauseDeclaration(statement.importClause)) continue;
				if (!f.is.namedImports(statement.importClause.namedBindings)) continue;
				if (statement.moduleSpecifier.text !== importPath) continue;

				for (const importElement of statement.importClause.namedBindings.elements) {
					if (importElement.propertyName) {
						if (importElement.propertyName.text === name) {
							identifier = importElement.name;
							break start;
						}
					} else {
						if (importElement.name.text === name) {
							identifier = importElement.name;
							break start;
						}
					}
				}
			}
		}

		if (!identifier) importInfo.entries.push({ name, identifier: (identifier = f.identifier(name, true)) });

		return identifier;
	}

	getSourceFile(node: ts.Node) {
		return ts.getSourceFileOfNode(node);
	}

	getSymbol(node: ts.Node, followAlias = true): ts.Symbol | undefined {
		if (f.is.classDeclaration(node) && f.is.identifier(node.name)) {
			return this.getSymbol(node.name);
		}

		const symbol = this.typeChecker.getSymbolAtLocation(node);

		if (symbol && followAlias) {
			return ts.skipAlias(symbol, this.typeChecker);
		} else {
			return symbol;
		}
	}

	hash(id: number) {
		const hashPrefix = this.config.hashPrefix;
		const salt = this.config.salt ?? this.buildInfo.getSalt();
		const hashGenerator = new Hashids(salt, 2);
		if (this.isGame && !hashPrefix) {
			return `${hashGenerator.encode(id)}`;
		} else {
			// If the package name is namespaced, then it can be used in
			// other projects so we want to add a prefix to the Id to prevent
			// collisions with other packages or the game.
			return `${hashPrefix ?? this.packageName}:${hashGenerator.encode(id)}`;
		}
	}

	getInternalId(node: ts.NamedDeclaration, extra: true): [isPackage: boolean, internalId: string];
	getInternalId(node: ts.NamedDeclaration): string;
	getInternalId(node: ts.NamedDeclaration, extra = false) {
		const filePath = this.getSourceFile(node).fileName;
		const fullName = getDeclarationName(node);
		const { directory, result } = getPackageJson(path.dirname(filePath));

		if (isPathDescendantOf(filePath, this.pathTranslator.rootDir)) {
			const outputPath = this.pathTranslator.getOutputPath(filePath).replace(/(\.lua)$/, "");
			const relativePath = path.relative(this.currentDirectory, outputPath);
			const internalId = `${result.name}:${relativePath.replace(/\\/g, "/")}@${fullName}`;
			return extra ? [false, internalId] : internalId;
		}

		const relativePath = path.relative(directory, filePath.replace(/(\.d)?.ts$/, "").replace(/index$/, "init"));
		const internalId = `${result.name}:${relativePath.replace(/\\/g, "/")}@${fullName}`;
		return extra ? [true, internalId] : internalId;
	}

	/**
	 * Format the internal id to be shorter, remove `out` part of path, and use hashPrefix.
	 */
	formatInternalid(internalId: string, hashPrefix = this.config.hashPrefix) {
		const match = new RegExp(`^@.*/.*:(.+)@(.+)$`).exec(internalId);
		if (!match) return internalId;

		const [, path, name] = match;
		const revisedPath = path.replace(/^(.*)[\/\\]/, "");
		return `${hashPrefix}:${revisedPath}@${name}`;
	}

	getUid(node: ts.NamedDeclaration) {
		const [isPackage, internalId] = this.getInternalId(node, true);
		const id = this.buildInfo.getIdentifierFromInternal(internalId);
		if (id) return id;

		// this is a package, and the package itself did not generate an id
		// use the internal ID to prevent breakage between packages and games.
		if (isPackage) {
			const buildInfo = this.buildInfo.getBuildInfoFromFile(this.getSourceFile(node).fileName);
			if (buildInfo) {
				const prefix = buildInfo.getIdentifierPrefix();
				if (prefix) {
					return this.formatInternalid(internalId, prefix);
				}
			}
			return internalId;
		}

		const newId = !this.config.obfuscation
			? this.formatInternalid(internalId)
			: this.hash(this.buildInfo.getLatestId());
		this.buildInfo.addIdentifier(internalId, newId);
		return newId;
	}

	obfuscateText(text: string, context?: string) {
		return this.config.obfuscation ? this.buildInfo.hashString(text, context) : text;
	}

	public hasErrors = false;
	addDiagnostic(diag: ts.DiagnosticWithLocation) {
		if (diag.category === ts.DiagnosticCategory.Error) {
			this.hasErrors = true;
		}

		this.context.addDiagnostic(diag);
	}

	private prereqStack = new Array<Array<ts.Statement>>();
	capture<T>(cb: () => T): [T, ts.Statement[]] {
		this.prereqStack.push([]);
		const result = cb();
		return [result, this.prereqStack.pop()!];
	}

	prereq(statement: ts.Statement) {
		const stack = this.prereqStack[this.prereqStack.length - 1];
		if (stack) stack.push(statement);
	}

	prereqList(statements: ts.Statement[]) {
		const stack = this.prereqStack[this.prereqStack.length - 1];
		if (stack) stack.push(...statements);
	}

	isCapturing(threshold = 1) {
		return this.prereqStack.length > threshold;
	}

	transform<T extends ts.Node>(node: T): T {
		return ts.visitEachChild(node, (newNode) => transformNode(this, newNode), this.context);
	}

	private _shouldViewFile(file: ts.SourceFile) {
		const fileName = path.posix.normalize(file.fileName);
		if (IGNORE_RBXTS_REGEX.test(fileName)) return false;

		const buildCandidates = Cache.buildInfoCandidates!;
		for (const candidate of buildCandidates) {
			let realPath = Cache.realPath.get(candidate);
			if (!realPath) Cache.realPath.set(candidate, (realPath = fs.realpathSync(candidate)));

			const candidateDir = path.dirname(realPath);
			if (
				isPathDescendantOf(file.fileName, candidateDir) &&
				!isPathDescendantOf(file.fileName, path.join(candidateDir, "node_modules"))
			) {
				return true;
			}
		}

		return false;
	}

	shouldViewFile(file: ts.SourceFile) {
		const cached = Cache.shouldView?.get(file.fileName);
		if (cached !== undefined) return cached;

		const result = this._shouldViewFile(file);
		Cache.shouldView.set(file.fileName, result);

		return result;
	}
}

interface ImportItem {
	name: string;
	identifier: ts.Identifier;
}

interface ImportInfo {
	path: string;
	entries: Array<ImportItem>;
}
